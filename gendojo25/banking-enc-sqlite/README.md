# Age encrypt sqlites datafile

```sh
docker compose run --rm bank101
```

## Age Help

```sh
age --help
Usage:
    age [--encrypt] (-r RECIPIENT | -R PATH)... [--armor] [-o OUTPUT] [INPUT]
    age [--encrypt] --passphrase [--armor] [-o OUTPUT] [INPUT]
    age --decrypt [-i PATH]... [-o OUTPUT] [INPUT]

Options:
    -e, --encrypt               Encrypt the input to the output. Default if omitted.
    -d, --decrypt               Decrypt the input to the output.
    -o, --output OUTPUT         Write the result to the file at path OUTPUT.
    -a, --armor                 Encrypt to a PEM encoded format.
    -p, --passphrase            Encrypt with a passphrase.
    -r, --recipient RECIPIENT   Encrypt to the specified RECIPIENT. Can be repeated.
    -R, --recipients-file PATH  Encrypt to recipients listed at PATH. Can be repeated.
    -i, --identity PATH         Use the identity file at PATH. Can be repeated.

INPUT defaults to standard input, and OUTPUT defaults to standard output.
If OUTPUT exists, it will be overwritten.

RECIPIENT can be an age public key generated by age-keygen ("age1...")
or an SSH public key ("ssh-ed25519 AAAA...", "ssh-rsa AAAA...").

Recipient files contain one or more recipients, one per line. Empty lines
and lines starting with "#" are ignored as comments. "-" may be used to
read recipients from standard input.

Identity files contain one or more secret keys ("AGE-SECRET-KEY-1..."),
one per line, or an SSH key. Empty lines and lines starting with "#" are
ignored as comments. Passphrase encrypted age files can be used as
identity files. Multiple key files can be provided, and any unused ones
will be ignored. "-" may be used to read identities from standard input.

When --encrypt is specified explicitly, -i can also be used to encrypt to an
identity file symmetrically, instead or in addition to normal recipients.

Example:
    $ age-keygen -o key.txt
    Public key: age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p
    $ tar cvz ~/data | age -r age1ql3z7hjy54pw3hyww5ayyfg7zqgvc7w3j2elw8zmrj2kg5sfn9aqmcac8p > data.tar.gz.age
    $ age --decrypt -i key.txt -o data.tar.gz data.tar.gz.age
```

# Alternative to Full Database Encryption: Encrypting Sensitive Data Before Storage

When the encryption of an entire SQLite database isn't practical or desired, a viable alternative is to encrypt specific pieces of sensitive data before they are inserted into the database. This method allows for the selective protection of data, such as personal identifiers, financial information, or any other data deemed sensitive, without the need to encrypt the entire database file. This strategy involves encrypting individual data elements using cryptographic libraries before inserting them into the SQLite database.

# Banking101 - Simple Banking System

This project implements a basic banking system using Bash scripting and SQLite. It provides a command-line interface for managing bank accounts, performing transactions, and viewing account information.

## Prerequisites

- Docker
- Docker Compose

## File Structure

- `compose.yaml`: Docker Compose configuration file
- `Dockerfile`: Docker image definition for the banking application
- `banking.sh`: Main Bash script containing the banking system logic

## How to Run

1. Make sure you have Docker and Docker Compose installed on your system.
2. Clone this repository or ensure you have all the files in the same directory.
3. Open a terminal and navigate to the project directory.
4. Run the following command to start the application:

   ```
   docker compose run --rm bank101
   ```

   This command will build the Docker image (if not already built) and run the banking application.

## Features

The banking system provides the following features:

1. Create Account: Set up a new bank account with a unique ID.
2. Deposit: Add funds to an existing account.
3. Withdraw: Remove funds from an existing account.
4. Check Balance: View the current balance of an account.
5. Transfer: Move funds from one account to another.
6. Print Tables (Debug): Display all accounts and transactions (for debugging purposes).
7. View Transaction History: See the transaction history for a specific account or all accounts.

## Usage

Once you run the application, you'll be presented with a menu of options. Enter the number corresponding to the action you want to perform and follow the prompts.

Example:

```
Banking System Menu:

1. Create Account
2. Deposit
3. Withdraw
4. Check Balance
5. Transfer
6. Print Tables (Debug)
7. View Transaction History
8. Exit

Enter your choice:
```

## Database

The application uses an SQLite database (`bank.db`) to store account information and transactions. The database is automatically created if it doesn't exist when you first run the application.

## Notes

- The application runs in a Docker container, ensuring consistency across different environments.
- The `banking.sh` script is mounted as a volume in the Docker container, allowing for easy updates without rebuilding the image.
- All data is stored in the SQLite database within the container. If you need data persistence between runs, you may want to consider mounting a volume for the database file.

## Security Considerations

This is a simple demonstration project and lacks many security features that would be necessary for a real-world banking application. In a production environment, you would need to implement proper authentication, encryption, input validation, and other security measures.

## Contributing

Feel free to fork this repository and submit pull requests for any improvements or additional features you'd like to add.

## License

This project is open-source and available under the MIT License.